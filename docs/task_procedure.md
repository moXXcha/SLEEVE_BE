
# タスク実装手順書

## 概要

このドキュメントは、AI エージェントがタスク実装時に迷わないよう、`docs/general.md`の**Level 2（Subtask内の作業手順）**を詳細化したものです。
**スコープ**: Subtask内の実装準備〜PR作成までの詳細手順

**位置づけ**:
- `docs/general.md`: タスク全体とSubtask内の大まかな流れを定義
- `docs/task_procedure.md`（本ドキュメント）: Subtask内の実装の詳細手順とテンプレート

## 関連ドキュメント

- **全体フロー**: `docs/general.md` - 開発タスクの全体フロー
- **コーディング規約**: `docs/BE_coding_roles.md` - アーキテクチャとコーディング規約
- **コーディングスタイル**: `docs/coding_guide.md` - コーディングスタイルガイド
- **Git 運用**: `docs/github.md` - Git Flow 運用とコミット規約
- **DB 操作**: `docs/DB_manual.md` - データベース操作手順
- **Linter/Formatter**: `docs/lint_format_manual.md` - コード品質管理

---

## 1. 実装前準備

### 1.1 ドキュメント確認

- `docs/BE_coding_roles.md`のコーディング規約を再確認
- `docs/DB_manual.md`の内容を確認（DB 変更が必要な場合）
- `docs/db_schema.md`の現在のスキーマを確認（DB 変更が必要な場合）
- 作業計画書（`docs/tasks/[JiraのID]_[タスク名]/task_plan.md`）の内容を再確認
- テストの通過基準を再確認

**重要**: DB変更を行う場合は、`docs/DB_manual.md` の手順に従い、**必ず `docs/db_schema.md` を更新してください**。これは必須事項です。

### 1.2 環境確認

- 現在のディレクトリでインストール済みモジュールを確認
- 重複インストールを避けるため、既存の依存関係をチェック
- 必要なライブラリのバージョン確認

---

## 2. 実装実行

### 2.1 メッセージ定義の作成

メッセージ定義は、**実装ファイル（Goコード）** と **ドキュメント（Markdown）** の2つを作成します。

#### 2.1.1 実装ファイルの作成

実装時は、作業計画書で考案したメッセージを基に、`app/messages/[feature]/`にGoファイルを作成します。

- `app/messages/[feature]/` ディレクトリに機能ごとのエラーメッセージ・ログメッセージをGoファイルで実装
- 機能固有のメッセージは `app/messages/[feature]/errors.go` と `app/messages/[feature]/logs.go` に配置
- 複数機能で共通で使用するメッセージは `app/messages/common/errors.go` と `app/messages/common/logs.go` に配置
- コードからはこの定義を参照するように実装
- **重要**: 作業計画書の`docs/messages/[feature]/`で定義したメッセージを、`app/messages/[feature]/`に実装してください

**実装ファイルの例**：
```go
// app/messages/user/errors.go
package user

const (
    ErrUserNotFound = "ユーザーが見つかりません"
    ErrInvalidEmail = "メールアドレスの形式が不正です"
    ErrDuplicateEmail = "このメールアドレスは既に登録されています"
)
```

#### 2.1.2 ドキュメントファイルの作成

- `docs/messages/[feature]/` ディレクトリに対応するMarkdownファイルを作成
- 「いつ・どのメッセージが出るか」「どのような条件で出力されるか」を日本語で記述
- 実装ファイルと同じディレクトリ構造を保つ

**ドキュメントファイルの例**：
```markdown
# ユーザー機能 - エラーメッセージ

## ErrUserNotFound
- **メッセージ**: "ユーザーが見つかりません"
- **出力タイミング**: ユーザーIDで検索した際に該当するユーザーが存在しない場合
- **関連関数**: `get_user_by_id`, `update_user`
- **HTTPステータス**: 404

## ErrInvalidEmail
- **メッセージ**: "メールアドレスの形式が不正です"
- **出力タイミング**: ユーザー登録・更新時にメールアドレスのバリデーションが失敗した場合
- **関連関数**: `create_user`, `update_user_email`
- **HTTPステータス**: 400
```

#### 2.1.3 ディレクトリ構造

**実装ファイル（app/messages/）**：
```
app/messages/
  user/              # ユーザー機能のメッセージ
    errors.go        # ユーザー関連のエラーメッセージ定義
    logs.go          # ユーザー関連のログメッセージ定義
  item/              # アイテム機能のメッセージ
    errors.go
    logs.go
  coordinate/        # コーデ機能のメッセージ
    errors.go
    logs.go
  common/            # 共通メッセージ
    errors.go        # 共通エラーメッセージ定義
    logs.go          # 共通ログメッセージ定義
```

**ドキュメントファイル（docs/messages/）**：
```
docs/messages/
  user/              # ユーザー機能のメッセージドキュメント
    errors.md        # エラーメッセージの説明
    logs.md          # ログメッセージの説明
  item/              # アイテム機能のメッセージドキュメント
    errors.md
    logs.md
  coordinate/        # コーデ機能のメッセージドキュメント
    errors.md
    logs.md
  common/            # 共通メッセージドキュメント
    errors.md        # 共通エラーメッセージの説明
    logs.md          # 共通ログメッセージの説明
```

### 2.2 実装ファイルの作成・変更

#### 2.2.1 機能分割と依存関係の整理

- 作業計画書の「作成ファイル」を機能単位で細分化
- 各機能の依存関係を整理し、依存関係の少ない順に実装順序を決定
- 各機能が独立してテスト可能な単位に分割されていることを確認

#### 2.2.2 実装順序の決定

**実装順序の原則:**

1. **基盤機能** → **ビジネスロジック** → **API 層** → **統合**
2. 依存関係の少ない機能から順次実装
3. 各機能実装後に単体テストを実行

**実装順序例:**

```
1. Domain層（モデル、エラー定義）
2. Repository層（データアクセス）
3. UseCase層（ビジネスロジック）
4. GraphQL層（API定義、リゾルバー）
5. Middleware層（認証、バリデーション）
6. 統合テスト
```

#### 2.2.3 段階的実装手順

**各機能の実装手順:**

1. **機能設計**

   - 機能の入出力を明確に定義
   - エラーケースを洗い出し
   - 単体テストのテストケースを設計

2. **インターフェース定義**

   - 関数・メソッドのシグネチャを定義
   - 引数・戻り値の型を明確化
   - エラー型を定義

3. **単体テストの作成**

   - 正常系のテストケースを作成
   - 異常系のテストケースを作成
   - エッジケースのテストケースを作成
   - テストが失敗することを確認（Red）

4. **実装**

   - 最小限の実装でテストを通す（Green）
   - リファクタリング（Refactor）

5. **単体テストの実行とエラー対処**

   - 単体テストを実行
   - テストが全て通過した場合は次のステップへ
   - **テスト失敗時**: 「2.2.7 テスト失敗・実装不具合時の修正手順」に従って対処
     - エラー分析 → 原因調査 → 修正方針の決定 → 修正実行 → 元の動線への復帰

6. **次の機能へ**
   - 実装した機能をコミット
   - 次の機能の実装に進む

#### 2.2.4 各層の実装詳細

**Domain 層の実装:**

- エンティティ・値オブジェクトの定義
- ドメインエラーの定義
- ビジネスルールの実装
- ドメインサービスの実装

**Repository 層の実装:**

- インターフェースの定義
- データベースアクセスの実装
- エラーハンドリングの実装
- トランザクション管理

**重要: DB変更時の必須作業とタイミング**

Repository層の実装でテーブルの作成・編集・削除を行った場合、**以下の手順を即座に実行してください**：

**実行タイミング: Repository層の実装完了直後（即座に実行）**

1. `ent/schema/` のスキーマファイルを更新
2. **必ず `docs/db_schema.md` を更新**（dbdiagram.io形式）
3. 両者の内容が一致していることを確認
4. スキーマ更新の内容をコミット

**PR作成前の最終確認:**
- DB変更を行った場合は、`docs/db_schema.md`が最新の状態に更新されていることを確認
- PRディスクリプションのチェックリストに「DB変更を行った場合は `docs/db_schema.md` を更新している」の項目を確認

詳細は `docs/DB_manual.md` の「手順4: スキーマの更新」を参照

**なぜ即座に更新するのか:**
- 後回しにすると更新漏れが発生しやすい
- 複数のテーブル変更がある場合、どの変更が未反映か分からなくなる
- PR作成時に慌てて更新すると、記載漏れや誤りが発生しやすい

**UseCase 層の実装:**

- ビジネスロジックの実装
- Repository 層との連携
- バリデーション処理
- エラーハンドリング

**GraphQL 層の実装:**

- スキーマ定義
- リゾルバーの実装
- 入力バリデーション
- エラーレスポンス

#### 2.2.5 実装時の品質管理

**コード品質チェック:**

- 各機能実装後に`golangci-lint run --fix`を実行
- コードカバレッジを確認
- 命名規則の遵守
- コメントの適切な記述

**テスト品質チェック:**

- テストカバレッジ 80%以上を維持
- テストケースの網羅性確認
- テストの可読性・保守性確認
- モックの適切な使用

#### 2.2.6 実装進捗管理

**進捗確認項目:**

- 作業計画書の「作成ファイル」の進捗確認
- 作業計画書の「変更ファイル」の進捗確認
- 各機能の単体テスト通過状況
- 依存関係の解決状況

**問題発生時の対応:**

- 実装困難な機能は詳細調査
- 依存関係の問題は設計見直し
- テスト失敗時はデバッグ実行
- 必要に応じて作業者に相談

#### 2.2.7 テスト失敗・実装不具合時の修正手順

**テスト失敗時の対応手順:**

1. **エラー分析**

   - エラーメッセージを詳細に確認
   - 失敗したテストケースを特定
   - エラーの種類を分類（コンパイルエラー、ランタイムエラー、ロジックエラー）

2. **原因調査**

   - テストコードの内容を確認
   - 実装コードの該当箇所を特定
   - 入力データと期待値の確認
   - 依存関係の状態確認

3. **修正方針の決定**

   - 修正が必要な箇所を特定
   - 修正方法を複数検討
   - 影響範囲を評価
   - 最小限の修正で済むかを確認

4. **修正実行**

   - 修正前の状態をコミット（必要に応じて）
   - 段階的に修正を適用
   - 各修正後にテストを実行
   - 修正が他の機能に影響していないか確認

5. **元の動線への復帰**
   - 修正が完了したら単体テストを再実行
   - 次の機能の実装に進む
   - 必要に応じて修正内容をコミット

**実装不具合時の対応手順:**

1. **不具合の特定**

   - 期待される動作と実際の動作の差異を確認
   - 不具合が発生する条件を特定
   - ログやエラーメッセージを確認

2. **デバッグ実行**

   - デバッグ用のログを追加
   - ステップ実行で動作を確認
   - 変数の値や状態を確認
   - 呼び出しスタックを確認

3. **修正方針の決定**

   - 不具合の根本原因を特定
   - 修正方法を複数検討
   - 修正による影響範囲を評価
   - テストケースの追加・修正が必要かを確認

4. **修正実行**

   - 修正前の状態をバックアップ
   - 段階的に修正を適用
   - 各修正後に動作確認
   - 関連するテストケースを実行

5. **元の動線への復帰**
   - 修正が完了したら全テストを実行
   - 不具合が解消されていることを確認
   - 次の機能の実装に進む
   - 修正内容をコミット

**復帰時のチェックリスト:**

- 修正した機能の単体テストが全て通過
- 既存の機能に影響がないことを確認
- コードカバレッジが維持されている
- Linter エラーがない
- 次の実装ステップが明確

**復帰できない場合の対応:**

- 問題を詳細に記録
- デバッグ調査書（`docs/tasks/[JiraのID]_[タスク名]/debug.md`）を作成
- 作業者に状況を報告
- 修正方針を複数提案
- 作業者の承認を得てから次のアクションを実行

#### 2.2.8 エディタ（Linter）エラーの対処手順

**Linterエラー発生時の対応手順:**

1. **Linter実行**

```bash
cd app
golangci-lint run --fix
```

2. **エラー分類**

   - コーディングスタイル違反（変数のスコープ、定義と初期化の分離、改行ルールなど）
   - 命名規則違反（関数名、変数名、ファイル名など）
   - 未使用の変数・インポート
   - エラーハンドリング不足
   - その他のベストプラクティス違反

3. **関連ドキュメント参照**

   - **スタイル違反の場合**: `docs/coding_guide.md` を参照
     - 変数定義のルール（1.1 変数定義の位置と初期化）
     - 改行ルール（2. 改行ルール）
     - 関数の記述スタイル（4. 関数の記述スタイル）
   - **命名規則違反の場合**: `docs/BE_coding_roles.md` を参照
     - 変数の命名規則
     - 関数の命名規則
     - ファイルの命名規則
   - **Linter詳細の場合**: `docs/lint_format_manual.md` を参照
     - 各Linterの詳細説明
     - エラーの対応方法

4. **修正実行**

   - `--fix`オプションで自動修正可能なものは自動修正される
   - 手動修正が必要なものは、該当箇所を修正
   - 修正後に再度`golangci-lint run --fix`を実行

5. **確認**

   - Linterエラーが0件になったことを確認
   - 単体テストを再実行（修正が既存機能を壊していないか確認）
   ```bash
   go test ./...
   ```

6. **元の動線への復帰**

   - Linterエラーが解消されたら、実装の続きに進む
   - または次の機能の実装に進む

**よくあるLinterエラーと対処方法:**

- **変数のスコープ問題**: `docs/coding_guide.md` 1.1参照
  - 関数全体で使わない変数を関数の最上位で宣言している
  - → その変数が使われるスコープ（if、for、switchなど）の最上位で宣言する

- **定義と初期化の分離問題**: `docs/coding_guide.md` 1.1参照
  - `:=`を使って定義と初期化を同時に行っている（例外：for文のrange句）
  - → `var`で定義、改行、`=`で初期化に分離する

- **改行ルール違反**: `docs/coding_guide.md` 2.参照
  - 初期化と実装の間に改行がある
  - → 初期化と実装の間の改行を削除する

- **未使用の変数・インポート**:
  - 使用していない変数やインポートがある
  - → 削除するか、使用するコードを追加する

**復帰できない場合の対応:**

- Linterエラーの原因が不明な場合
- 修正方法が分からない場合
- デバッグ調査書（`docs/tasks/[JiraのID]_[タスク名]/debug.md`）を作成
- 作業者に状況を報告し、承認を得る

### 2.3 コード品質チェック

- `app/`ディレクトリ内で`golangci-lint run --fix`を実行
- Linter エラーを修正（詳細は「2.2.8 エディタ（Linter）エラーの対処手順」を参照）
- コードフォーマットを適用

---

## 3. Git Commit 手順

### 3.1 コミット前準備

#### 3.1.1 変更内容の確認

```bash
# 変更されたファイルを確認
git status

# 変更内容を確認
git diff
```

#### 3.1.2 ステージング

```bash
# 特定のファイルをステージング
git add [ファイルパス]

# または全ての変更をステージング
git add .
```

### 3.2 コミット実行

#### 3.2.1 コミットメッセージの作成

コミットメッセージは `docs/github.md` の「コミットメッセージ規約」に従って作成してください。

#### 3.2.2 コミット実行

```bash
git commit -m "[コミットメッセージ]"
```

### 3.3 コミット後確認

#### 3.3.1 コミット内容確認

```bash
# 最新のコミット内容を確認
git log --oneline -1

# コミットの詳細を確認
git show HEAD
```

### 3.4 コミット頻度のガイドライン

コミット頻度のガイドラインについては、`docs/github.md` の「コミット頻度のガイドライン」セクションを参照してください。

**主なポイント:**

- **機能単位**: 1 つの機能が完成したらコミット
- **テスト単位**: テストが通るようになったらコミット
- **修正単位**: 1 つのバグが修正されたらコミット
- 動作しないコードのコミットは避ける
- テストが通らない状態でのコミットは避ける

詳細は `docs/github.md` の「コミット頻度のガイドライン」を参照してください。

---

## 4. PR作成とレビューフロー

### 4.1 PR作成前の確認

PR作成前に、以下を確認してください：

- 全ての単体テストが通過している
- `golangci-lint run --fix`でLinterエラーがない
- 全ての変更がコミット・プッシュされている
- コミットメッセージが規約に従っている

### 4.2 PR作成

#### 4.2.1 GitHub CLI（`gh`）を使用してPR作成

```bash
# 依存関係がない場合（topic branchへのPR）
gh pr create --base topic/[親ID]_[機能名] --title "[SubtaskID]: [タスク名]" --body-file docs/tasks/[JiraのID]_[タスク名]/pr_description_[SubtaskID].md

# 依存関係がある場合（依存先feature branchへのPR）
gh pr create --base feature/[依存先SubtaskID]_[機能名] --title "[SubtaskID]: [タスク名]" --body-file docs/tasks/[JiraのID]_[タスク名]/pr_description_[SubtaskID].md

# 単一タスクの場合（mainへのPR）
gh pr create --base main --title "[JiraのID]: [タスク名]" --body-file docs/tasks/[JiraのID]_[タスク名]/pr_description.md
```

#### 4.2.2 PR作成が失敗する場合

PR内容を`docs/tasks/[JiraのID]_[タスク名]/pr_description_[SubtaskID].md`に作成し、作業者に手動作成を依頼してください。

PRディスクリプションのテンプレートは `.github/pull_request_template.md` を参照してください。

### 4.3 レビュー待機フロー（現状の運用）

**⚠️ 注意：以下は現状の運用です。メンバーが増えた際は変更される可能性があります。**

#### 4.3.1 レビュアー

- **オーナーがレビューを行います**

#### 4.3.2 レビュー待ちの動き

- ❌ **レビュー待ちの間、他のSubtaskに進まない**
- ✅ **PR作成後は、オーナーのレビュー・承認・マージを完全に待つ**
- ✅ **レビュー中に他の作業を進めない**

**理由：**
- 現状は少人数開発のため、並行作業によるコンフリクトを避ける
- レビューでの修正指示を即座に反映できるようにする
- ブランチ管理をシンプルに保つ

**将来の変更予定：**
- メンバーが増えた際は、依存関係のないSubtaskを並行開発できるように変更する可能性があります

#### 4.3.3 レビュー中の対応

1. **PR作成後**
   - オーナーに通知
   - レビュー待ちの状態で待機

2. **修正依頼があった場合**
   - 指摘された箇所を修正
   - 追加のコミットを作成
   - プッシュして再レビュー依頼

3. **承認された場合**
   - オーナーがマージを実行
   - マージ完了を確認

### 4.4 マージ後の処理

#### 4.4.1 Feature Branchの削除

```bash
# ローカルブランチを削除
git branch -d feature/[SubtaskID]_[機能名]

# リモートブランチを削除（GitHubのPRマージ時に自動削除される場合もある）
git push origin --delete feature/[SubtaskID]_[機能名]
```

#### 4.4.2 Topic/Main Branchの最新化

マージ後、親ブランチ（TopicまたはMain）を最新化してください。

```bash
# Topic Branchを最新化（複数Subtaskの場合）
git checkout topic/[親ID]_[機能名]
git pull origin topic/[親ID]_[機能名]

# Main Branchを最新化（単一タスクの場合）
git checkout main
git pull origin main
```

#### 4.4.3 次のSubtaskへの準備

次のSubtaskに進む前に、以下を確認してください：

- 前のSubtaskのFeature Branchが削除されている
- Topic/Main Branchが最新化されている
- 作業ディレクトリがクリーンな状態になっている

### 4.5 依存関係があるSubtaskのマージ順序

**ケース: topic → task1 → task2 のようにブランチが切られている場合**

依存関係がある場合のマージは、**変更差分を見やすくする**ために以下の順序で行います。

#### 4.5.1 具体的な手順

```
前提:
- topic/SLEEVE-100_user_authentication (親ブランチ)
- feature/SLEEVE-102_user_model (task1)
- feature/SLEEVE-103_login_api (task2: 102に依存)
```

**ステップ1: task1を実装・PR作成**

```bash
# task1をtopicから分岐して実装
git checkout topic/SLEEVE-100_user_authentication
git checkout -b feature/SLEEVE-102_user_model

# 実装・テスト・コミット...

# PR作成（base: topic）
gh pr create --base topic/SLEEVE-100_user_authentication --title "SLEEVE-102: Userモデルの作成"
```

**ステップ2: task1をtopicにマージ**

- オーナーがレビュー・承認
- Squash and mergeでtopicにマージ
- task1のFeature Branchを削除

**ステップ3: task2を実装・PR作成**

```bash
# task2をtask1から分岐して実装
git checkout feature/SLEEVE-102_user_model
git checkout -b feature/SLEEVE-103_login_api

# 実装・テスト・コミット...

# PR作成（base: task1）
gh pr create --base feature/SLEEVE-102_user_model --title "SLEEVE-103: ログインAPIの実装"
```

**ステップ4: task1がtopicにマージ済みなので、task2をtopicにマージ**

task1が既にtopicにマージされているため、task2の変更差分だけをtopicに取り込みます。

```bash
# task2のPRのベースをtopicに変更するか、新しいPRを作成
# （この時点でtask2にはtask1の変更も含まれているが、topicには既にtask1がマージ済み）

# 新しいPRを作成する場合
git checkout feature/SLEEVE-103_login_api
gh pr create --base topic/SLEEVE-100_user_authentication --title "SLEEVE-103: ログインAPIの実装"
```

- オーナーがレビュー・承認
- Squash and mergeでtopicにマージ（**task2の変更差分だけがマージされる**）
- task2のFeature Branchを削除

**理由:**
- task1 → task2 と分岐することで、task2のPRではtask2の変更だけが見やすくなる
- 最終的にはtopicに両方マージされるが、レビュー時に変更差分が明確になる

---

## 5. ドキュメントテンプレート

各種ドキュメントのテンプレートは、以下のファイルを参照してください：

### 5.1 作業計画書テンプレート

**テンプレートファイル**: `docs/templates/task_plan.md`

作業計画書は `docs/tasks/[JiraのID]_[タスク名]/task_plan.md` として作成してください。

### 5.2 実装詳細書テンプレート

**テンプレートファイル**: `docs/templates/implementation_details.md`

実装詳細書は `docs/tasks/[JiraのID]_[タスク名]/implementation_details.md` として作成してください。

### 5.3 PRディスクリプションテンプレート

**テンプレートファイル**: `.github/pull_request_template.md`

PRディスクリプションは、GitHub上で自動的にこのテンプレートが適用されます。必要に応じて `docs/tasks/[JiraのID]_[タスク名]/pr_description_[SubtaskID].md` として事前に内容を作成することもできます。

### 5.4 Topic PR ディスクリプションテンプレート

**テンプレートファイル**: `docs/templates/topic_pr_description.md`

Topic BranchからmainへのPR作成時は、`docs/tasks/[JiraのID]_[タスク名]/topic_pr_description.md` として作成してください。

### 5.5 Jira Subtask内容テンプレート

**テンプレートファイル**: `docs/templates/subtask_list.md`

複数サブタスクに分割する場合、Subtask内容を `docs/tasks/[JiraのID]_[タスク名]/subtask_list.md` として作成してください。

作業者がこの内容を基にJiraでSubtaskを手動作成します。作成後、Subtask IDを受け取り、作業計画書に反映してください。

### 5.6 デバッグ調査書テンプレート

**テンプレートファイル**: `docs/templates/debug.md`

デバッグ調査書は `docs/tasks/[JiraのID]_[タスク名]/debug.md` として作成してください。

---

## 6. 実装時の注意事項

### 6.1 コーディング規約

- `docs/BE_coding_roles.md`の内容を厳守
- `docs/coding_guide.md`のコーディングスタイルを厳守
- Go 言語の標準的なコーディング規約に従う
- 変数名・関数名は英語で記述
- コメントは日本語で記述（必要に応じて）

### 6.2 エラーハンドリング

- エラーメッセージは `docs/messages/` で定義したものを使用
- 適切なエラーレベルの設定
- ログ出力の統一性を保つ

### 6.3 依存関係管理

- 既存の依存関係を確認
- バージョン競合を解決
- 必要最小限の依存関係のみ追加

---

## 7. チェックリスト

### 7.1 実装開始前

- 作業計画書の承認確認
- コーディング規約の確認
- 環境・依存関係の確認
- DB変更が必要な場合は `docs/db_schema.md` の現在のスキーマを確認

### 7.2 実装中

- メッセージ定義の作成
- コーディング規約の遵守
- 適切なコミット頻度でのコミット

### 7.3 実装完了時

- Linter エラーの解消
- コードフォーマットの適用
- DB変更を行った場合は `docs/db_schema.md` の更新を確認
- 最終コミットの実行
