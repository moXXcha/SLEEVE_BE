
# タスク実装手順書

## 概要

このドキュメントは、AI エージェントがタスク実装時に迷わないよう、`docs/general.md`の「3. 実装」セクションを詳細化したものです。
**スコープ**: ドキュメント確認以降〜テスト前までの実装手順

## 関連ドキュメント

- **全体フロー**: `docs/general.md` - 開発タスクの全体フロー
- **コーディング規約**: `docs/BE_coding_roles.md` - アーキテクチャとコーディング規約
- **Git 運用**: `docs/github.md` - Git Flow 運用とコミット規約
- **DB 操作**: `docs/DB_manual.md` - データベース操作手順
- **Linter/Formatter**: `docs/lint_format_manual.md` - コード品質管理

---

## 1. 実装前準備

### 1.1 ドキュメント確認

- `docs/BE_coding_roles.md`のコーディング規約を再確認
- `docs/DB_manual.md`の内容を確認（DB 変更が必要な場合）
- 作業計画書（`docs/tasks/[JiraのID]_[タスク名]/task_plan.md`）の内容を再確認
- テストの通過基準を再確認

### 1.2 環境確認

- 現在のディレクトリでインストール済みモジュールを確認
- 重複インストールを避けるため、既存の依存関係をチェック
- 必要なライブラリのバージョン確認

---

## 2. 実装実行

### 2.1 メッセージ定義の作成

- `docs/messages/` ディレクトリにエラーメッセージ・ログメッセージを日本語で定義
- ファイル名は `[機能名]_message.go` 形式で作成
- コードからは定義したメッセージを参照するように実装

### 2.2 実装ファイルの作成・変更

#### 2.2.1 機能分割と依存関係の整理

- 作業計画書の「作成ファイル」を機能単位で細分化
- 各機能の依存関係を整理し、依存関係の少ない順に実装順序を決定
- 各機能が独立してテスト可能な単位に分割されていることを確認

#### 2.2.2 実装順序の決定

**実装順序の原則:**

1. **基盤機能** → **ビジネスロジック** → **API 層** → **統合**
2. 依存関係の少ない機能から順次実装
3. 各機能実装後に単体テストを実行

**実装順序例:**

```
1. Domain層（モデル、エラー定義）
2. Repository層（データアクセス）
3. UseCase層（ビジネスロジック）
4. GraphQL層（API定義、リゾルバー）
5. Middleware層（認証、バリデーション）
6. 統合テスト
```

#### 2.2.3 段階的実装手順

**各機能の実装手順:**

1. **機能設計**

   - 機能の入出力を明確に定義
   - エラーケースを洗い出し
   - 単体テストのテストケースを設計

2. **インターフェース定義**

   - 関数・メソッドのシグネチャを定義
   - 引数・戻り値の型を明確化
   - エラー型を定義

3. **単体テストの作成**

   - 正常系のテストケースを作成
   - 異常系のテストケースを作成
   - エッジケースのテストケースを作成
   - テストが失敗することを確認（Red）

4. **実装**

   - 最小限の実装でテストを通す（Green）
   - リファクタリング（Refactor）
   - 単体テストが全て通過することを確認

5. **次の機能へ**
   - 実装した機能をコミット
   - 次の機能の実装に進む

#### 2.2.4 各層の実装詳細

**Domain 層の実装:**

- エンティティ・値オブジェクトの定義
- ドメインエラーの定義
- ビジネスルールの実装
- ドメインサービスの実装

**Repository 層の実装:**

- インターフェースの定義
- データベースアクセスの実装
- エラーハンドリングの実装
- トランザクション管理

**UseCase 層の実装:**

- ビジネスロジックの実装
- Repository 層との連携
- バリデーション処理
- エラーハンドリング

**GraphQL 層の実装:**

- スキーマ定義
- リゾルバーの実装
- 入力バリデーション
- エラーレスポンス

#### 2.2.5 実装時の品質管理

**コード品質チェック:**

- 各機能実装後に`golangci-lint run --fix`を実行
- コードカバレッジを確認
- 命名規則の遵守
- コメントの適切な記述

**テスト品質チェック:**

- テストカバレッジ 80%以上を維持
- テストケースの網羅性確認
- テストの可読性・保守性確認
- モックの適切な使用

#### 2.2.6 実装進捗管理

**進捗確認項目:**

- 作業計画書の「作成ファイル」の進捗確認
- 作業計画書の「変更ファイル」の進捗確認
- 各機能の単体テスト通過状況
- 依存関係の解決状況

**問題発生時の対応:**

- 実装困難な機能は詳細調査
- 依存関係の問題は設計見直し
- テスト失敗時はデバッグ実行
- 必要に応じて作業者に相談

#### 2.2.7 テスト失敗・実装不具合時の修正手順

**テスト失敗時の対応手順:**

1. **エラー分析**

   - エラーメッセージを詳細に確認
   - 失敗したテストケースを特定
   - エラーの種類を分類（コンパイルエラー、ランタイムエラー、ロジックエラー）

2. **原因調査**

   - テストコードの内容を確認
   - 実装コードの該当箇所を特定
   - 入力データと期待値の確認
   - 依存関係の状態確認

3. **修正方針の決定**

   - 修正が必要な箇所を特定
   - 修正方法を複数検討
   - 影響範囲を評価
   - 最小限の修正で済むかを確認

4. **修正実行**

   - 修正前の状態をコミット（必要に応じて）
   - 段階的に修正を適用
   - 各修正後にテストを実行
   - 修正が他の機能に影響していないか確認

5. **元の動線への復帰**
   - 修正が完了したら単体テストを再実行
   - 全てのテストが通過することを確認
   - 次の機能の実装に進む
   - 必要に応じて修正内容をコミット

**実装不具合時の対応手順:**

1. **不具合の特定**

   - 期待される動作と実際の動作の差異を確認
   - 不具合が発生する条件を特定
   - ログやエラーメッセージを確認

2. **デバッグ実行**

   - デバッグ用のログを追加
   - ステップ実行で動作を確認
   - 変数の値や状態を確認
   - 呼び出しスタックを確認

3. **修正方針の決定**

   - 不具合の根本原因を特定
   - 修正方法を複数検討
   - 修正による影響範囲を評価
   - テストケースの追加・修正が必要かを確認

4. **修正実行**

   - 修正前の状態をバックアップ
   - 段階的に修正を適用
   - 各修正後に動作確認
   - 関連するテストケースを実行

5. **元の動線への復帰**
   - 修正が完了したら全テストを実行
   - 不具合が解消されていることを確認
   - 次の機能の実装に進む
   - 修正内容をコミット

**復帰時のチェックリスト:**

- 修正した機能の単体テストが全て通過
- 既存の機能に影響がないことを確認
- コードカバレッジが維持されている
- Linter エラーがない
- 次の実装ステップが明確

**復帰できない場合の対応:**

- 問題を詳細に記録
- デバッグ調査書（`docs/tasks/[JiraのID]_[タスク名]/debug.md`）を作成
- 作業者に状況を報告
- 修正方針を複数提案
- 作業者の承認を得てから次のアクションを実行

### 2.3 コード品質チェック

- `app/`ディレクトリ内で`golangci-lint run --fix`を実行
- Linter エラーを修正
- コードフォーマットを適用

---

## 3. Git Commit 手順

### 3.1 コミット前準備

#### 3.1.1 変更内容の確認

```bash
# 変更されたファイルを確認
git status

# 変更内容を確認
git diff
```

#### 3.1.2 ステージング

```bash
# 特定のファイルをステージング
git add [ファイルパス]

# または全ての変更をステージング
git add .
```

### 3.2 コミット実行

#### 3.2.1 コミットメッセージの作成

コミットメッセージは `docs/github.md` の「コミットメッセージ規約」に従って作成してください。

#### 3.2.2 コミット実行

```bash
git commit -m "[コミットメッセージ]"
```

### 3.3 コミット後確認

#### 3.3.1 コミット内容確認

```bash
# 最新のコミット内容を確認
git log --oneline -1

# コミットの詳細を確認
git show HEAD
```

### 3.4 コミット頻度のガイドライン

#### 3.4.1 推奨されるコミット頻度

- **機能単位**: 1 つの機能が完成したらコミット
- **テスト単位**: テストが通るようになったらコミット
- **修正単位**: 1 つのバグが修正されたらコミット
- **リファクタリング単位**: リファクタリングが完了したらコミット
- **段階的実装**: 各実装ステップ（設計 → テスト → 実装 → リファクタリング）でコミット

#### 3.4.2 避けるべきコミット

- 動作しないコードのコミット
- 複数の機能を一度にコミット
- テストが通らない状態でのコミット
- 意味のないコミット（「作業中」など）
- 大きな変更を一度にコミット

#### 3.4.3 コミットタイミングの判断基準

**コミットすべきタイミング:**

- 単体テストが全て通過した時
- 1 つの機能が完全に動作するようになった時
- リファクタリングが完了した時
- バグ修正が完了した時
- コードレビュー可能な状態になった時

**コミットを避けるべきタイミング:**

- コンパイルエラーがある時
- テストが失敗している時
- 作業途中で機能が不完全な時
- 複数の変更が混在している時

---

## 4. ドキュメントテンプレート

### 4.1 作業計画書テンプレート

作業計画書は `docs/tasks/[JiraのID]_[タスク名]/task_plan.md` として作成してください。

````markdown
# チケット ID, タスク名

# 作業内容確認

# テストの通過基準

- [テストケース 1:（例）正常なユーザー情報が返却されること]
  - 通過条件: [具体的な記述]
- [テストケース 2:（例）存在しないユーザー ID でエラーが返ること]
  - 通過条件: [具体的な記述]

# 使用技術（ライブラリなどを version まで）

# 作成ファイル

- [作成するファイルパス]
  - [ファイルを作成する目的や、その内容の要約]

# 変更ファイル

- [変更するファイルパス]
- [ファイルを変更する目的や、その内容の要約]

# E2E テスト計画

- **Request Header:**
  ```json
  {
    "Content-Type": "application/json",
    "Authorization": "Bearer <token>"
  }
  ```
````

- **Request Body (Query/Mutation):**
  ```graphql
  query GetUser {
    user(id: "1") {
      id
      name
    }
  }
  ```

# 影響範囲

- [この変更によって影響を受ける可能性のある他の機能やモジュール]

````

### 4.2 実装詳細書テンプレート

実装詳細書は `docs/tasks/[JiraのID]_[タスク名]/implementation_details.md` として作成してください。

```markdown
# チケット ID, タスク名

## 概要

（タスクの目的と達成されたことを簡潔に記述）

## 変更内容

### 1. ファイル名

- （変更内容の詳細、追加・変更・削除したコードの概要）

### 2. ファイル名

- （変更内容の詳細、追加・変更・削除したコードの概要）
  ...

## テスト

### E2E テスト

- （E2E テストの概要と、どのようなケースを検証したか）

### 単体テスト

- （単体テストの概要と、どのようなケースを検証したか）

## 考慮事項

- （実装上の注意点、トレードオフ、今後の課題など）
````

### 4.3 デバッグ調査書テンプレート

デバッグ調査書は `docs/tasks/[JiraのID]_[タスク名]/debug.md` として作成してください。

```markdown
# 不具合内容

# エラー文（出力されている場合）

# エラー箇所（特定できている場合）

# 修正方針（複数提案すること）

1. [方針 1]
2. [方針 2]
3. ...

# 修正の影響範囲

- [修正による影響が及ぶ可能性のある範囲]
```

---

## 5. 実装時の注意事項

### 5.1 コーディング規約

- `docs/BE_coding_roles.md`の内容を厳守
- Go 言語の標準的なコーディング規約に従う
- 変数名・関数名は英語で記述
- コメントは日本語で記述（必要に応じて）

### 5.2 エラーハンドリング

- エラーメッセージは `docs/messages/` で定義したものを使用
- 適切なエラーレベルの設定
- ログ出力の統一性を保つ

### 5.3 依存関係管理

- 既存の依存関係を確認
- バージョン競合を解決
- 必要最小限の依存関係のみ追加

---

## 6. チェックリスト

### 6.1 実装開始前

- 作業計画書の承認確認
- コーディング規約の確認
- 環境・依存関係の確認

### 6.2 実装中

- メッセージ定義の作成
- コーディング規約の遵守
- 適切なコミット頻度でのコミット

### 6.3 実装完了時

- Linter エラーの解消
- コードフォーマットの適用
- 最終コミットの実行
